# LINQ у .NET: Технічна реалізація базових методів і суміжні концепції.


Всім привіт! Мене звати Олексій, я працюю .NET розробником в компанії GlobalLogic. Крім цього, періодично проводжу курси та вебінари по .NET, де ділюся своїм досвідом і знаннями. На написання цієї статті мене надихнули студенти, коли вони побачили, як знання, набуті на курсах, застосовуються в LINQ, а точніше — в його внутрішній реалізації. З практики також можу відмітити, що багато розробників користуються методами LINQ, проте не розуміють, як він влаштований «під капотом». Сподіваюсь, ця стаття трошки привідкриє завісу магії LINQ та дасть розуміння імплементації базових методів.

## Проблематика
Перш ніж перейти до реалізації базових методів, пропоную замислитися над однією з проблем, яку вирішує LINQ. Уявімо ситуацію: у нас є клас Student, що має кілька властивостей — Id (унікальний ідентифікатор), Name (ім'я студента) та Age (його вік).
```csharp
public class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
}
```
Також маємо колекцію, наприклад List, яка типізована класом Student і містить в собі кілька студентів.
```csharp
List<Student> students = new List<Student>
{
    new Student { Id = 1, Name = "John", Age = 18 },
    new Student { Id = 2, Name = "Alice", Age = 20 },
    new Student { Id = 3, Name = "Bob", Age = 22 }
};
```
Тепер, маючи такий набір даних, уявімо, що нам потрібно відфільтрувати студентів за віком. Для цього ми можемо використовувати метод Where из LINQ . Наприклад, якщо ми хочемо знайти студентів старше 18 років, ми можемо зробити це наступним чином:
```csharp
var filteredStudents = students.Where(s => s.Age > 18);
```
Пропоную на деякий час забути про цей метод і, загалом, про LINQ, та пройти шлях самурая, спробувавши реалізувати метод Where самостійно. Для цього пропоную зробити кілька ітерацій реалізації, поступово покращуючи підхід на кожному етапі. Почнемо з простої задачі — створення методу, який буде відбирати студентів, вік яких перевищує 18 років.

## Створення простого методу для фільтрації
Спочатку пропоную визначитися з сигнатурою методу. В якості першого аргументу метод має приймати колекцію типу List, яка типізована класом Student, тобто це колекція, яку ми будемо фільтрувати. Другим аргументом будемо передавати вік, за яким хочемо виконати фільтрацію. А повертатиме метод колекцію типу List<Student>, тобто відфільтрованих за віком студентів.
```csharp
public List<Student> FilterStudentsByAge(List<Student> students, int age)
```
Тіло методу можна реалізувати наступним чином: спочатку створимо порожню колекцію типу List<Student> під назвою result, куди будемо додавати студентів, які будуть старші за переданий вік, тобто тих, чий вік більший за другий аргумент методу. Далі створимо цикл foreach, який буде ітерувати вхідну колекцію студентів. У тілі циклу додамо умовну конструкцію if, в якій перевіримо: якщо вік студента перевищує заданий поріг, ми додаємо його до нової колекції, інакше — ігноруємо. Після завершення циклу повернемо нову колекцію як результат роботи методу. І для простоти, поки помістимо цей метод в звичайний класс, який назвемо Service. На першому етапі метод виглядатиме так:
```csharp
public class Service
{
    public List<Student> FilterStudentsByAge(List<Student> students, int ageThreshold)
    {
        List<Student> result = new List<Student>();
        
        foreach (var student in students)
        {
            if (student.Age > ageThreshold)
            {
                result.Add(student);
            }
        }
        
        return result;
    }
}
```
Працювати з цим методом можна наступним чином:
```csharp
Service service = new Service();
List<Student> filteredStudents = service.FilterStudentsByAge(students, 18);
```
Тепер ускладнимо задачу: уявіть, що нам потрібно знайти студентів, вік яких дорівнює 18 років, або всіх студентів, чиє ім'я починається з певної літери. Як бути в такій ситуації? Простим варіантом, який одразу приходить на думку, було б створити нові методи, змінивши їх назви та умови фільтрації під час ітерації колекції. Але очевидною проблемою, яка виникає, є дублювання коду, що не є оптимальним рішенням. Тому наступним кроком буде впровадження делегатів у нашу реалізацію методу.
## Делегати в якості аргументу методу
На початку цього пункту хотілося б у двох словах нагадати, що таке делегат і які системні делегати існують у .NET. Перш за все, делегат — це спеціальний тип даних, який зберігає посилання на методи. Делегати також можна передавати як параметри до інших методів або використовувати для реалізації подій. У .NET існують три основні системні делегати: Action, Func та Predicate. Давайте коротко згадаємо про кожен із цих делегатів:

* Action — це делегат, який представляє методи, що не повертають значення. Він може приймати один або кілька параметрів, що робить його корисним для виконання дій, які не вимагають результату.

* Func — це делегат, який використовується для методів, що повертають значення. Він може приймати від одного до 16 параметрів, причому останній параметр завжди є типом, що представляє значення, яке повертається.

* Predicate — це делегат, який представляє методи, що повертають логічне значення (true або false). Він приймає один параметр і зазвичай використовується для перевірки певних умов, що робить його корисним у випадках, коли потрібно фільтрувати або шукати дані в колекціях.

Тепер, згадавши теорію, ми можемо зробити наш метод більш гнучким, щоб він приймав різні умови для фільтрації колекції. Для цього потрібно замінити другий аргумент методу, який раніше представляв вік, на делегат. Тут постає питання: який саме делегат вибрати? Нам потрібен такий делегат, який приймає параметр типу Student та повертає булеве значення залежно від виконання умови. Для цього нам ідеально підійде делегат Func<Student, bool>, де Student — тип аргументу, а bool — тип, що повертається. Тоді сигнатура методу буде виглядати наступним чином: 
```csharp
public List<Student> FilterStudentsByAge(List<Student> students, Func<Student, bool> predicate)
```
У тілі самого методу нам потрібно внести мінімальні зміни: достатньо викликати метод, сполучений з делегатом, для цього потрібно на аргументі predicate викликати метод Invoke. Модифікований метод виглядатиме так:
```csharp
public static List<Student> FilterStudentsByAge(List<Student> students, Func<Student, bool> predicate)
{
        List<Student> result = new List<Student>();
        
        foreach (var student in students)
        {
            if (predicate.Invoke(student))
            {
                result.Add(student);
            }
        }
        
        return result;
}
```
Однак виникає цікаве питання: як тепер викликати метод FilterStudentsByAge? До речі, цей метод можно перейменувати в FilterStudents, оскільки тепер він фільтрує не лише за віком, а за будь-якою умовою, яку ми передамо. Давайте розглянемо приклад виклику методу з умовою фільтрації за віком.
```csharp
Func<Student, bool> agePredicate = new Func<Student, bool>(AgeCondition);
Service.FilterStudents(students, agePredicate);

static bool AgeCondition(Student student)
{
    if (student.Age > 18)
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
У цьому прикладі ми створили окремий метод AgeCondition, який описує умову фільтрації за віком. Далі ми створюємо екземпляр делегата Func<Student, bool> під назвою agePredicate, який сполучаємо з цим методом і передаємо його в метод FilterStudents.Такий підхід дозволяє створювати будь-який метод, що описує умову фільтрації, та передавати цю умову в метод FilterStudents. Тобто фактично, при ітерації студентів у циклі foreach, ми будемо викликати метод AgeCondition для кожного студента через виклик Invoke на predicate в методі FilterStudents.
Модна сказати, що в FilterStudents ми дозволили розширювати функціонал методу без його модифікації, тобто фактично ми імплементували принципип відкритості/закритості (OCP) з SOLID принципів. Наступним етапом ми можемо спростити метод AgeCondition, замінивши логіку умовної конструкції if- else на тернарний оператор, що зробить код більш компактним і читабельним: 

```csharp
static bool AgeCondition(Student student)
{
    return student.Age > 18? true: false;
}
```
або зробивши, ще простіше, залишивши в якості повертаймого значення тільки умову: 
```csharp
static bool AgeCondition(Student student)
{
    return student.Age > 18;
}
```
Далі, мона було б використати техніку передбачення делегату, спростивши створення єкземпляру делегату, та виклик методу: 
```csharp
Func<Student, bool> agePredicate = AgeCondition;
Service.FilterStudents(students, agePredicate);
```
І нарешті, можна скористатись анонімними методами — це методи без імені, які можна визначити безпосередньо при виклику делегата. Вони використовуються для передачі логіки в делегати без створення окремого методу, що спрощує життя, адже немає необхідності створювати окремий метод для кожної логіки. У нашому випадку це виглядатиме так:
```csharp
Func<Student, bool> agePredicate = delegate (Student student) { return student.Age > 18; };
Service.FilterStudents(students, agePredicate);
```
Або ще простіше, можна використати лямбда-вирази — це більш компактний і читабельний спосіб визначення анонімних методів. Лямбда-вирази використовують стрілочний оператор => для вказівки параметрів і тіла методу.
```csharp
Func<Student, bool> agePredicate = student => student.Age > 18;
Service.FilterStudents(students, agePredicate);
```
І останнє спрощення в цьому пункті полягає в тому, що ми можемо видалити змінну agePredicate типу Func<Student, bool> і одразу передавати лямбда-вираз безпосередньо як аргумент методу. На завершення цього пункту, весь наш код, включно з викликом методу для фільтрації, виглядатиме наступним чином:
```csharp
Service.FilterStudents(students, student => student.Age > 18);

public class Service
{
    public static List<Student> FilterStudents(List<Student> students, Func<Student, bool> predicate)
    {
        List<Student> result = new List<Student>();

        foreach (var student in students)
        {
            if (predicate.Invoke(student))
            {
                result.Add(student);
            }
        }

        return result;
    }
}
```
Наступним кроком пропоную зробити цей метод ще більш універсальним, щоб він міг працювати не тільки з колекцією типу List<Student>, а й з List<T>, де T — будь-який тип. Для цього нам потрібно використати узагальнення.
## Розширення можливостей LINQ за допомогою узагальнених методів
Спочатку знову трішки теорії: узагальнення, або generics, — це концепція, яка дозволяє створювати класи, інтерфейси та методи, що працюють з параметризованими типами. Це дає змогу створювати більш гнучкий та повторно використовуваний код, оскільки можна працювати з різними типами даних, не вказуючи їх конкретно до моменту створення екземпляру классу або використання методу. У нашому випадку нам потрібно просто замість використання типу Student вказати універсальний параметр типу, який можна назвати, наприклад, TSource. Відповідно, потрібно перейменувати перший аргумент методу, змінивши його з students на source, а також змінити змінну ітерації з student на element в тілі самого методу. Звісно, потрібно також перейменувати сам метод, оскільки він тепер фільтрує не тільки студентів, а й будь-який список, закритий конкретним типом. Пропоную поки його назвати Filter.
```csharp
Service.Filter(students, student => student.Age > 18);

public class Service
{
    public static List<TSource> Filter<TSource>(List<TSource> source, Func<TSource, bool> predicate)
    {
        List<TSource> result = new List<TSource>();

        foreach (var element in source)
        {
            if (predicate.Invoke(element))
            {
                result.Add(element);
            }
        }

        return result;
    }
}
```
На цьому етапі ми отримали метод, який може відфільтрувати список, закритий будь-яким типом, за будь-якою умовою, яку ми передаватимемо в якості аргументу. Проте, цей метод поки що не є повністю універсальним, оскільки він працює лише з однією колекцією — List. Наступним кроком у покращенні пропоную додати можливість використання цього методу з будь-якою колекцією.
## Використання інтерфейсів IEnumerable та IEnumerator
На початку варто зазначити, що IEnumerable та IEnumerator — це інтерфейси, які дозволяють ітерувати колекції. У загальному випадку, щоб колекція вважалася справжньою колекцією, вона повинна реалізувати обидва ці інтерфейси. Таким чином, усі колекції в .NET реалізують два інтерфейси - IEnumerable та IEnumerator. Для того, щоб розібратись, як працюють ці два інтерфейси, та які методи вони 
в собі містять, можемо уявити що в нас немає циклу foreach, який використовуюэтся для інтерацій колеекцій. 

На початку варто зазначити, що IEnumerable та IEnumerator — це інтерфейси, які дозволяють ітерувати колекції. У загальному випадку, щоб колекція вважалася справжньою колекцією, вона повинна реалізувати обидва інтерфейси. Таким чином, усі колекції в .NET реалізують ці два інтерфейси. Тепер детальніше: фактично, IEnumerable забезпечує доступ до ітератора, який повертає IEnumerator. IEnumerator, у свою чергу, дозволяє перебирати елементи колекції. Якщо уявити, що в C# немає циклу foreach, для ітерації нам довелося б використовувати ці інтерфейси напряму. Це означає, що ми б отримували доступ до кожного елемента колекції вручну, викликаючи методи MoveNext() та Current на IEnumerator, щоб перейти до наступного елемента. Давайте розглянемо приклад. Візьмемо нашу колекцію List<Student> і переберемо її, виводячи на консоль інформацію про кожного студента. Перш за все, нам потрібно привести нашу колекцію до базового інтерфейсного типу IEnumerable:
```csharp
IEnumerable enumerable = (IEnumerable)students;
```
Тут ми використали UpCast — приведення до базового інтерфейсного типу. Насправді, у цьому випадку можна спростити вираз і не вказувати явне приведення, оскільки UpCast виконується автоматично.Остаточний вигляд буде таким:
```csharp
IEnumerable enumerable = students;
```
Далі на змінній enumerable ми можемо викликати метод GetEnumerator, який поверне об'єкт типу IEnumerator. До речі, метод GetEnumerator — це єдиний метод, що входить до інтерфейсу IEnumerable, і його основне призначення полягає в поверненні ітератора, тобто об'єкта типу IEnumerator.
```csharp
IEnumerator enumerator = enumerable.GetEnumerator();
```